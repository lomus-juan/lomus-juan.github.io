[{
  "section": "Blog",
  "slug": "/blog/auth/cas-%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE/",
  "title": "CAS认证协议",
  "description": "Centeral Authentication Service 基于web的单点登录认证协议。它允许一个用户通过一个凭证（如用户名和密码）在多个应用程序中实现身份验证。CAS主要用于web环境中，它通过提供一个中央服务器来处理认证请求，使得用户只需登录一次，就可以访问多个不同的服务。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/CAS_hu8941322591550221942.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"251\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/CAS_hu15229380802327357366.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/CAS_hu7262136231622394150.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/CAS_hu2913655968577482089.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "认证, 协议",
  "tags": "OIDC, 认证",
  "content":"介绍 Centeral Authentication Service 基于web的单点登录认证协议。它允许一个用户通过一个凭证（如用户名和密码）在多个应用程序中实现身份验证。CAS 主要用于 web环境中，它通过提供一个中央服务器来处理认证请求，使得用户只需登录一次，就可以访问多个不同的服务。\n概念 CAS client: 需要单点登录访问的应用。 CAS server：负责处理用户的认证请求并提供一个集中的认证服务，主要功能：认证用户，生成票据，服务票据分发，票据验证。\nTGT:Ticket Granting Ticket用户身份认证成功后，CAS会为用户签发登录票据，通过此票据可以证明用户已经登录成功，后续的服务访问而无需重新认证，CAS会将此票据存储起来，可以有效期内一直使用。\n[!INFO] TGT是一种特殊的票据，它能够“授予”或生成其他类型的票据，即Service Ticket（ST）。当用户想要访问一个受保护的服务时，他们会使用TGT来请求一个ST，ST是用于访问特定服务的临时凭证。\nTGC：存储在浏览器中的认证中心 cookie,认证成功后会返回一个 TGC到浏览器，与 TGC关联。 ST：一个临时的、一次性的凭据，由认证服务器生成，并颁发给已经通过身份验证的用户。用户使用这个服务票据来访问一个或多个服务，而不需要在每个服务上重新进行身份验证。一旦服务票据被验证，它通常就会被废弃，以防止重放攻击。\n接入流程 第三方应用在认证中心进行服务注册，确保第三方应用能够通过认证中心进行单点登录。 第三方应用后台增加认证 filter（具体实现的话，可以是集成 cas apereo 的 cas-client相关依赖，也可以是集成 spring security cas相关依赖）。 cas client集成参考：cas client单点登录集成 认证过程 用户访问第三方应用的目标地址， 后台认证 filter检测到请求未认证，携带着目标地址重定向到认证中心的登录页面 用户登录成功之后，会生成用户登录成功的票据：TGT\u0026amp;TGC，并生成 ST,将 TGC和 ST返回给用户浏览器，重定向到第三方应用的目标地址，此时携带着 ST。 应用程序收到带有服务票据的请求后，会将其发送回 CAS服务器进行验证。 CAS服务器验证服务票据的有效性。如果服务票据有效，CAS服务器返回认证响应：是否成功，成功的话携带用户信息。ST使用后此时已失效，第三方应用可以据此创建会话。 当第三方应用会话过期或被清理后，如果 TGT还在有效期内，但此时 ST已经过期，还是会重定向到登录页面，不过此时不需要再次输入用户名密码，可能会看到页面闪烁（为了更好的用户体验，CAS实现可能会使用一个透明的中间页面或者直接在后台完成新的ST的发放，从而避免用户看到登录页面的闪现） 参考 CAS协议分析\nCAS认证原理\nCAS\n"},{
  "section": "Blog",
  "slug": "/blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/",
  "title": "mysql中的字符集",
  "description": "UTF-8是Unicode的一种实现方式，几乎包含世界上所有字符，方便国际化，通常使用此字符集。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/mofulu_hu4833971661374046724.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"308\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/mofulu_hu7519190031598437039.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/mofulu_hu3420733187749655371.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/mofulu_hu15311228695990020107.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "数据库, MySQL",
  "tags": "MySQL, 字符集",
  "content":"字符集 UTF-8是Unicode的一种实现方式，几乎包含世界上所有字符，方便国际化，通常使用此字符集。\nMySQL 中的 utf8 和 utf8mb4 UTF8 一个字符由 1-6 字节组成，但现在使用的字符最长只有 4 个字节。MySQL 中的 utf8 字符集最多只能存储 3 个字节，因此碰到 4 字节的字符就无法存储，这就是为什么 utf8 字符集的字段无法存储 emoji 表情的原因。 utf8mb4 是 utf8 的扩展，它可以存储 4 个字节的字符，因此可以存储 emoji 表情。 如无特殊情况，都应该使用 utf8mb4 字符集，不再使用 utf8 字符集。\n排序规则 是否区分大小写 ci（Case Insensitive）：这个排序规则表示大小写不敏感的排序。在使用ci排序规则时，大写和小写字母被视为相同，因此在排序字符串时不会考虑它们的大小写差异。例如，字符串 Apple和 apple在使用ci排序规则时会被视为相等。关键字搜索时**A%和a%**搜索的结果一致.\ncs（Case Sensitive）：这个排序规则表示大小写敏感的排序。在使用“cs”排序规则时，大写和小写字母被视为不同的字符，因此在排序字符串时会严格区分它们的大小写差异。例如，字符串 Apple和apple在使用cs排序规则时会被视为不同。 在创建数据库或表时，可以通过设置 COLLATE关键字来指定特定的排序规则。例如： utf8mb4_0900_ai_ci 名称解析：utf8mb4 是字符集，0900_ai_ci 是排序规则。ci 代表不区分大小写（case-insensitive）。 [[不同数据库中的特性]]\n是否区分重音 在某些特定场景下，区分重音是非常重要的。以下是一些需要区分重音的情况：\n需要区分重音的场景 语言特性：某些语言的词义可能因重音的不同而改变。例如，在法语中，“a”（有重音）和“à”（无重音）是两个不同的词，具有不同的含义。在这种情况下，区分重音是必要的。 精确匹配：在某些应用中，用户可能希望进行精确匹配，例如在搜索引擎或数据库查询中，用户输入的内容必须与数据库中的内容完全一致，包括重音。 文化和语言敏感性：在处理某些文化或语言时，重音可能会影响到用户的体验和理解，因此需要特别注意。 区分重音的排序规则 如果你需要在 MySQL 中区分重音，可以使用以下排序规则：\nutf8mb4_0900_as_cs：这个排序规则表示： as：区分重音（Accent Sensitive） cs：区分大小写（Case Sensitive） utf8mb4_general_ci：虽然这个排序规则是不区分重音的，但如果你需要更细致的控制，可以考虑使用 utf8mb4_unicode_ci，它在某些情况下会更准确地处理重音，但仍然是不区分重音的。 utf8mb4_unicode_as：如果你使用的是 MySQL 8.0 或更高版本，可以使用 utf8mb4_unicode_as，它支持区分重音。 示例 如果你想要创建一个表并使用区分重音的排序规则，可以使用以下 SQL 语句：\nCREATE TABLE example ( name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_as_cs ); 在这个表中，name 列将区分重音和大小写。\n规则解析 utf8_general_ci 表示一种通用的排序规则。general 排序规则在比较字符时，采用了一些简化的规则，通常不会考虑重音符号（如 é 和 e 被视为相同），并且在比较时也不区分大小写（例如，A 和 a 被视为相同）。 utf8mb4_0900_ai_ci mysql8之后默认的字符集排序规则版本 0900：表示使用 Unicode 9.0 版本的字符集。 常见字符集 utf8mb4_general_ci ：不区分大小写, 校对速度快, 但准确度稍差，不区分重音。 通常可以选用 utf8mb4_bin:：字符串每个字符串用二进制数据编译存储。 区分大小写,而且可以存二进制的内容。 utf8mb4_unicode_ci：不区分大小写, 校准确度高,但校对速度稍慢。,区分重音\n参考： mysql的字符集和排序规则\nci,cs,bin\n"},{
  "section": "Blog",
  "slug": "/blog/auth/oauth2.0-%E6%8E%88%E6%9D%83%E5%8D%8F%E8%AE%AE/",
  "title": "Oauth2.0授权协议",
  "description": "OAuth2.0是一种授权协议，**允许第三方应用在用户授权的情况下，在不暴露用户密码给第三方应用的前提下安全地访问服务器资源**,同时可以提供有限的权限范围，限制第三方应用能够访问的资源，提高了安全性。认证成功之后会返回Acces Token，第三方应用可以用Access Token换取所需要的资源。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/oauth2.0-header_hu4923300124730013342.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"380\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/oauth2.0-header_hu16763331291001887679.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/oauth2.0-header_hu7777967825155084502.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/oauth2.0-header_hu17174806846330419517.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "授权, 协议",
  "tags": "Oauth2.0, 授权",
  "content":"定义 OAuth2.0是一种授权协议，允许第三方应用在用户授权的情况下，在不暴露用户密码给第三方应用的前提下安全地访问服务器资源,同时可以提供有限的权限范围，限制第三方应用能够访问的资源，提高了安全性。认证成功之后会返回Acces Token，第三方应用可以用Access Token换取所需要的资源。\n重点概念 资源所有者：Resource Owner(RO)： 拥有受保护资源的实体，通常指终端用户。\n资源服务器：Resource Server（RS） 资源的存储位置。\n客户端：client 请求访问受保护资源的第三方应用。\n授权服务器：authorization server(AS) 验证资源身份者，颁发令牌。多数情况下授权服务器需要验证资源拥有者身份，授权服务器也要提供认证功能。\n授权令牌: Access Token（AT） 授权服务器提供给客户端访问受保护资源的第三方应用。\n授权许可：Authorization Grant 是资源拥有者授权给客户端的一个凭据，表明资源拥有者同意客户端代表他访问受保护的资源。授权许可的类型包括授权码、隐式授权、资源拥有者密码凭据和客户端凭据。\n整体流程 当第三方客户端 client需要访问资源拥有者 RO所拥有的资源的时候，向用户发出授权许可 Authorization Grant； 资源拥有者RO批准授权，将授权许可返回给第三方客户端； 第三方客户端拿着用户的授权许可去换取访问令牌 Access Token； 授权服务器 AS确定第三方客户端client身份和资源拥有者RO身份后返回访问令牌给第三方客户端； 第三方客户端使用访问令牌访问资源； 资源服务器 RS验证访问令牌（发送给授权服务器验证等），返回许可访问的资源， 四种授权方式 OAuth2.0支持四种授权方式，以适应不同的场景。\n新增概念 客户端凭据（Client Credentials）授权服务器验证客户端身份的凭证，通常是ClientId\u0026amp;ClientSecret\n授权码授权 概念 授权码流程是最常见的一种。使用的授权许可 Authorization Grant是授权码 Authorization Code，授权码在前端传递，有效期很短且单次有效，第三方应用后台服务获取到后授权码后，携带着客户端凭据和授权码到授权中心换取访问令牌 Access Token，再拿着访问令牌换取资源。\n流程 流程与OAuth2.0整体流程相似，关注点主要在： 第二步重定向到授权服务器地址的时候需要携带的参数：\nresponse_type：必填，其值通常是 code，表示客户端希望使用授权码流程。\nclient_id：必填，表示客户端的ID，这是在授权服务器上注册客户端时获得的。\nredirect_uri：必填，指定授权服务器在完成用户认证和授权后应该重定向用户的URI。这个URI必须在客户端注册时提供给授权服务器。\nscope：选填，用于指定客户端请求的权限范围。例如，read或 write等。\nstate：推荐，用于防止跨站请求伪造（CSRF）攻击。客户端生成一个随机值，并在授权请求中发送。授权服务器在重定向回客户端时应该原样返回这个值，客户端可以验证它以确认响应是来自预期的授权请求。\n请求示例\nGET /authorize?response_type=code\u0026amp;client_id=CLIENT_ID\u0026amp;redirect_uri=https%3A%2F%2Fclient.example.com%2Fcallback\u0026amp;scope=read%20write\u0026amp;state=xyz HTTP/1.1 Host: authorization-server.com 返回结果 对应第四步授权服务器携带着授权码重定向到第三方应用\nHTTP/1.1 302 Found Location: https://client.example.com/callback?code=SplxlOBeZQQYbYS6WxSbIA\u0026amp;state=xyz 第五步第三方应用携带着授权码请求访问令牌的时候需要的其他参数：\ngrant_type：必填，这个参数必须设置为 authorization_code，以指明客户端正在使用授权码授权流程。 code：必填，之前在授权请求阶段从授权服务器获得的授权码。 redirect_uri：必填，在用户授权时使用的重定向URI，必须与获取授权码时使用的重定向URI相同。 client_id：必填，客户端应用的ID，这是在应用注册授权服务器时获得的。 client_secret：推荐，通常情况客户端应用的密钥，这是在应用注册授权服务器时获得的。某些授权服务器可能要求在请求访问令牌时提供这个参数，以提高安全性。 请求示例 POST /token HTTP/1.1 Host: authorization-server.com Authorization: Basic base64encode(client_id:client_secret) -- 不同实现可能传入位置不同 Content-Type: application/x-www-form-urlencoded grant_type=authorization_code code=SplxlOBeZQQYbYS6WxSbIA -- 上个接口返回的 redirect_uri=REDIRECT_URI 响应示例：\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 { \u0026#34;access_token\u0026#34;: \u0026#34;ACCESS_TOKEN\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, \u0026#34;refresh_token\u0026#34;: \u0026#34;REFRESH_TOKEN\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write\u0026#34; } 优缺点\u0026amp;使用场景 安全性高:不会暴露Access Token,适合于大多数第三方应用； 有服务端：适用于有服务端的场景； 流程略复杂； 隐式授权 隐式（implicit）授权 ,不会生成授权码，会直接返回access token到前端,使用较少。\n流程 与授权码授权相比，隐式授权不返回授权码，直接返回了Access Token ,少了拿授权码换取Access Token的步骤。 重点关注的还是第二步： 第三方应用将用户浏览器重定向到授权服务器，并在请求中包含以下参数：\nresponse_type: 必须设置为 token，表示客户端请求直接返回访问令牌。\nclient_id: 客户端的标识符，注意：此模式无client secret。\nredirect_uri: 用户授权后授权服务器重定向到的URI。\nscope: 客户端请求的权限范围。\nstate: 客户端生成的一个随机字符串，用于防止跨站请求伪造（CSRF）攻击。\n请求示例\nGET /authorize?response_type=token\u0026amp;client_id=CLIENT_ID\u0026amp;redirect_uri=https://client-app.com/callback\u0026amp;scope=read_profile\u0026amp;state=随机字符串 HTTP/1.1 Host: authorization-server.com **响应示例** HTTP/1.1 302 Found Location: https://client-app.com/callback#access_token=ACCESS_TOKEN\u0026amp;token_type=bearer\u0026amp;expires_in=3600\u0026amp;scope=read_profile\u0026amp;state=随机字符串 优缺点\u0026amp;\u0026amp;适用场景 安全性较低：由于访问令牌直接在浏览器中传输，因此更容易受到中间人攻击。 无法刷新令牌：隐式授权流程不支持刷新令牌，一旦访问令牌过期，用户需要重新进行授权。 令牌泄露风险：由于令牌直接在客户端传递，如果客户端存在安全漏洞，令牌可能会被泄露。 无后端参与：适合纯前端，没有后端的网站。 密码授权 密码模式授权，直接将用户名密码交给第三方应用。这种方式不符合OAuth2.0的原则：第三方应用不应该拥有用户的凭证，增加了凭证泄露的风险。\n流程 步骤上重点在于第二步，第三方应用需要拿着用户的用户名密码去请求token。\n请求示例：\nPOST /token HTTP/1.1 Host: authorization-server.com Authorization: Basic base64encode(client_id:client_secret) Content-Type: application/x-www-form-urlencoded grant_type=password\u0026amp;username=USER\u0026amp;password=PASSWORD\u0026amp;scope=read 响应示例：\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;scope\u0026#34;:\u0026#34;read\u0026#34; } 优缺点\u0026amp;适用场景 安全性较低：客户端需要存储用户的用户名和密码，这增加了安全风险，尤其是在客户端遭受攻击的情况下。 信任问题：需要用户高度信任客户端应用，因为用户需要将自己的凭证信息提供给客户端。客户端应用高度信任，例如第一方应用。 不一定支持刷新令牌：虽然密码授权流程可以返回刷新令牌，但不是所有实现都支持，这意味着当访问令牌过期时，用户可能需要重新提供用户名和密码。 不适用于第三方应用：由于安全问题，密码授权不适用于第三方应用，因为第三方应用通常不被用户高度信任。 凭证授权 凭证（Client Credentials）授权主要用于服务器间通信的场景，适用于后台服务需要访问受保护的资源，不涉及到具体用户的资源访问，这部分资源应该是归属于后台服务的。\n流程 重点关注第二步，客户端使用其 client_id 和 client_secret 向授权服务器发送请求，请求一个访问令牌。这个请求通常不需要用户参与。\n请求示例\nPOST /token HTTP/1.1 Host: authorization-server.com Authorization: Basic base64encode(client_id:client_secret) Content-Type: application/x-www-form-urlencoded grant_type=client_credentials 响应示例\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;scope\u0026#34;:\u0026#34;read write\u0026#34; } 优缺点\u0026amp;适用场景 无用户参与：这种模式不需要用户交互，因此适用于没有用户参与的服务间通信。 访问令牌不包含用户信息：由于不涉及用户，因此访问令牌通常不包含用户信息。 有限的权限：通常，使用 Client Credentials 授权模式获得的访问令牌只能访问有限的资源或执行有限的操作，因为这些操作与最终用户无关。 适用于服务器到服务器的通信的有限数据访问的授权，不需要用户授权数据的场景。 refresh token 它用于在访问令牌（access token）过期后获取新的访问令牌，而无需用户再次进行身份验证。Refresh token 是一种长期有效的令牌，通常在用户同意应用程序进行授权后发放。\n与访问令牌不同，refresh token 不用于访问资源。它只在后台使用，用于获取新的访问令牌。当访问令牌过期时，客户端应用程序可以使用 refresh token 向授权服务器请求新的访问令牌，而无需用户参与。\n参考 Oauth2.0\nOAuth2.0 vs OIDC\nOauth2.0四种模式的场景\nOauth2.0\n开放平台鉴权以及OAuth2.0介绍 - duanxz - 博客园 (cnblogs.com)\n帮你深入理解OAuth2.0协议_SecCloud的专栏-CSDN博客_oauth2.0协议\nOAuth2.0协议 - 简书 (jianshu.com)\nOauth2.0 协议到底是干什么的？ - 知乎 (zhihu.com)\nOAuth 2.0 的一个简单解释 - 阮一峰的网络日志 (ruanyifeng.com)\nOAuth 2.0 的四种方式 - 阮一峰的网络日志 (ruanyifeng.com)\nGitHub OAuth 第三方登录示例教程 - 阮一峰的网络日志 (ruanyifeng.com)\n深入理解OAuth2.0 - duanxz - 博客园 (cnblogs.com)\nOAuth 的权限问题与信息隐忧 - duanxz - 博客园 (cnblogs.com)\n"},{
  "section": "Blog",
  "slug": "/blog/auth/oidc-%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE/",
  "title": "OIDC认证协议",
  "description": "OpenID Connect协议，允许第三方应用通过统一的认证中心进行身份认证，认证成功之后会返回ID token, 第三方应用可以据此建立会话。OIDC在OAuth2.0的基础上进行了身份认证的扩展，Oauth2.0拥有的授权功能，通常OIDC也可以支持。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu553666590164531326.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"128\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu15663941634987227926.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu1821980664999648304.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu6976548969821633984.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "认证, 协议",
  "tags": "OIDC, 认证",
  "content":"介绍 OIDC是基于OAuth2.0的身份认证协议.以下简单介绍下Oauth2.0: Oauth2.0 授权协议\nOIDC OpenID Connect 协议，允许第三方应用通过统一的认证中心进行身份认证，认证成功之后会返回ID token, 第三方应用可以据此建立会话。OIDC在OAuth2.0的基础上进行了身份认证的扩展，Oauth2.0拥有的授权功能，通常OIDC也可以支持。\n关于认证和授权的区别 认证，Authentication，认证的目标是让第三方应用知道当前登录的用户是谁，在OIDC中第三方应用通过ID token能够直接解析出当前登录的用户信息。 授权，Authorization, 授权的目标是知道当前用户能干啥，可以不知道这个用户是谁，在OAuth2.0中用户在认证服务器中认证成功之后，会返回当前用户的Access Token,第三方应用可以拿着Access Token 来换取当前用户所需要的用户资源。\n如果当前用户的Access Token 允许访问的资源中包含了用户信息，也可以根据Access Token换取用户信息，但是这种获取用户信息的方式是根据授予的权限访问资源，偏向于授权的概念。\nOIDC中新增的概念 ID token：OIDC认证成功后返回的JWT,里面包含了用户信息 身份提供者（Identity Provider, IdP）:负责用户身份认证并颁发ID token, access token。\n相当于OAuth2.0的授权服务器，只是在OAuth 2.0的框架中，授权服务器的主要职责是处理授权请求和颁发访问令牌。它并不直接负责身份认证的过程,但它在实际应用中常常与身份认证过程相结合，与OIDC中的IdP相差不大\n第三方应用（Relying Party, RP）：通过IdP验证身份的应用，对应OAuth2.0的client 声明（Claims）：ID token中包含的字段信息，例如用户的用户名、邮箱、登录时间、令牌的有效期等。这些信息由身份提供者（Identity Provider，IdP）在身份验证过程中生成，并传递给客户端（Relying Party，RP）。\nClaims和Scopes Scope是客户端在发起授权请求时定义的一系列权限，决定了客户端能够访问用户的哪些信息或资源。OIDC定义了一些标准的Scope，如openid、profile、email等。Claims需要的信息也需要包含在scopes中才能获取到。\n流程 OIDC的流程与OAuth2.0基本一致，支持OAuth2.0中的授权码模式，隐式授权模式，密码模式和隐式授权（OIDC1.1弃用，因为会隐式授权id token access token直接返回到前端并不安全） 主要区别在于第六步中的响应结果中，相对于OAuth2.0多了ID token\n{ \u0026#34;access_token\u0026#34;: \u0026#34;ACCESS_TOKEN\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, \u0026#34;id_token\u0026#34;: \u0026#34;ID_TOKEN\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;REFRESH_TOKEN\u0026#34; } ID Token eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.POstGetfAytaZS82wHcjoTyoqhMyxXiWdR7Nn7A29DNSl0EiXLdwJ6xC6AfgZWF1bOsS_TuYI3OG85AmiExREkrS6tDfTQ2B3WXlrr-wp5AokiRbz3_oB4OxG-W9KcEEbDRcZc0nH3L7LzYptiy1PtAylQGxHTWZXtGz4ht0bAecBgmpdgXMguEIcoqPJ1n3pIWk_dUZegpqx0Lka21H6XxUTxiy8OcaarA8zdnPUnV6AmNP3ecFawIFYdvJB_cm-GvpCSbr8G8y_Mllj8f4x9nBH8pQux89_6gUY618iYv7tuPWBFfEbLxtF2pZS6YC1aSfLQxeNe8djT9YjpvRZAQ 这个ID Token由三部分组成，分别是：\nHeader: 描述了JWT的签名算法和令牌类型。 Payload: 包含了关于用户身份和认证状态的实际信息。 Signature: 用于验证令牌完整性的签名。 以下是上述ID Token的解码后的Header和Payload部分： Header { \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } Payload\n{ \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;admin\u0026#34;: true, \u0026#34;iat\u0026#34;: 1516239022 } 以下是Payload中各个字段的含义：\nsub (Subject)：主题，通常是用户的唯一标识符，例如用户ID。 name：用户的姓名。 admin：表示用户是否是管理员。 iat (Issued At)：令牌的发行时间戳。 参考 OIDC协议的概述和工作流程\nOAuth2.0 vs OIDC\nOauth2.0四种模式的场景\nOauth2.0\n关于OIDC，一种现代身份验证协议\n"},{
  "section": "Blog",
  "slug": "/blog/%E6%9D%82%E8%B0%88/%E6%A8%A1%E4%BB%BF%E8%80%85/",
  "title": "",
  "description": "",
  "date": "1年1月1日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu553666590164531326.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"128\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu15663941634987227926.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu1821980664999648304.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu6976548969821633984.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "",
  "tags": "",
  "content":""},{
  "section": "Blog",
  "slug": "/blog/%E6%9D%82%E8%B0%88/%E8%AF%8D%E5%8F%A5/",
  "title": "",
  "description": "",
  "date": "1年1月1日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu553666590164531326.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"128\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu15663941634987227926.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu1821980664999648304.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu6976548969821633984.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "",
  "tags": "",
  "content":""}]
